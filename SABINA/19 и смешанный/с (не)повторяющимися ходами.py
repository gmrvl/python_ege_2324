#Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. Игроки ходят по очереди, первый ход
# делает Петя. За один ход игрок может добавить 3 камня, добавить 6 камней или увеличить количество камней в 2 раза, при
# этом нельзя повторять последний ход соперника.
#Игра завершается в тот момент, когда количество камней в куче становится более 40. Победителем считается игрок,
# сделавший последний ход.
#В начальный момент в куче было S камней, 2 ≤ S ≤ 36.
#Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
#Укажите такое максимальное допустимое значение S, при котором Петя не может выиграть за один ход, но при любом ходе
# Пети Ваня может выиграть своим первым ходом.

def f(s,m, moves=''):    # moves - ход в игре(мы запоминаем ходы в игре)
    if s > 40: return m % 2 == 0
    if m == 0: return 0
    h = []
    if moves[-1] != '1':     #проверка ,что последний код не 1(S + 3) и мы в этом случаем можем первый ход выполнить
        h.append(f(s + 3, m - 1, moves=moves+'1'))
    if moves[-1] != '2':
        h.append(f(s + 6, m - 1, moves=moves+'2'))
    if moves[-1] != '3'
        h.append(f(s * 2, m - 1, moves=moves+'3'))
    return any(h) if m % 2 != 0 else all(h)

print([s for s in range(2, 37) if f(s, 2)])
print([s for s in range(2, 37) if not f(s,1) and f(s, 3)])
print([s for s in range(2, 37) if not f(s,2) and f(s,4)])